"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const child_process_1 = __importDefault(require("child_process"));
const crypto_1 = __importDefault(require("crypto"));
const wait_on_1 = __importDefault(require("wait-on"));
const _1 = require(".");
const storage_jobs_1 = require("./storage-jobs");
const util_1 = require("./util");
beforeEach(function () {
    return __awaiter(this, void 0, void 0, function* () {
        this.timeout(120000);
        child_process_1.default.exec(`cd powergate-docker && BIGSECTORS=false make localnet`, (err) => {
            if (err) {
                throw err;
            }
        });
        yield wait_on_1.default({
            resources: ["http://0.0.0.0:6002", "http://0.0.0.0:5001"],
            timeout: 120000,
            validateStatus: function () {
                return true; // the call expectedly returns 404, so just allow that
            },
        });
    });
});
afterEach(function () {
    return __awaiter(this, void 0, void 0, function* () {
        this.timeout(120000);
        yield new Promise((resolve, reject) => {
            child_process_1.default.exec(`cd powergate-docker && make localnet-down`, (err, stdout) => {
                if (err) {
                    reject(err);
                }
                resolve(stdout);
            });
        });
    });
});
describe("pow", () => {
    it("should get build info", () => __awaiter(void 0, void 0, void 0, function* () {
        const pow = newPow();
        const res = yield pow.buildInfo();
        chai_1.expect(res.gitSummary).not.empty;
    }));
    it("should check host", () => {
        const pow = newPow();
        chai_1.expect(pow.host).equal(util_1.host);
    });
    it("should get user id", () => __awaiter(void 0, void 0, void 0, function* () {
        const pow = newPow();
        yield expectNewUser(pow);
        const res = yield pow.userId();
        chai_1.expect(res.id).not.empty;
    }));
    describe("admin", () => {
        describe("users", () => {
            it("should create user", () => __awaiter(void 0, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
            }));
            it("should list users", () => __awaiter(void 0, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const res = yield pow.admin.users.list();
                chai_1.expect(res.usersList).length.greaterThan(0);
            }));
        });
        describe("user storage jobs", () => __awaiter(void 0, void 0, void 0, function* () {
            it("should get executing", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    const pow = newPow();
                    const auth = yield expectNewUser(pow);
                    const addressees = yield expectAddresses(pow, 1);
                    yield waitForBalance(pow, addressees[0].address);
                    const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                    const jobId = yield expectApplyStorageConfig(pow, cid);
                    yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_EXECUTING);
                    const res = yield pow.admin.storageJobs.list({
                        userId: auth.id,
                        cidFilter: cid,
                        select: storage_jobs_1.ListSelect.Executing,
                    });
                    chai_1.expect(res.storageJobsList).length(1);
                    chai_1.expect(res.storageJobsList[0].id).equals(jobId);
                    chai_1.expect(res.storageJobsList[0].cid).equals(cid);
                });
            });
            it("should get queued", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    const pow = newPow();
                    const auth = yield expectNewUser(pow);
                    const addressees = yield expectAddresses(pow, 1);
                    yield waitForBalance(pow, addressees[0].address);
                    const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                    yield expectApplyStorageConfig(pow, cid);
                    const res = yield pow.admin.storageJobs.list({
                        userId: auth.id,
                        cidFilter: cid,
                        select: storage_jobs_1.ListSelect.Queued,
                    });
                    chai_1.expect(res.storageJobsList).length.lessThan(2);
                });
            });
            it("should get summary", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    const pow = newPow();
                    const auth = yield expectNewUser(pow);
                    const addressees = yield expectAddresses(pow, 1);
                    yield waitForBalance(pow, addressees[0].address);
                    const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                    const jobId = yield expectApplyStorageConfig(pow, cid);
                    let res = yield pow.admin.storageJobs.summary(auth.id, cid);
                    chai_1.expect(res.executingStorageJobsList).length(1);
                    res = yield pow.admin.storageJobs.summary(auth.id, cid);
                    chai_1.expect(res.executingStorageJobsList).length(1);
                    chai_1.expect(res.executingStorageJobsList[0]).equals(jobId);
                });
            });
        }));
        describe("all storage jobs", () => {
            it("should get summary", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    this.timeout(180000);
                    const pow = newPow();
                    yield expectNewUser(pow);
                    const addressees = yield expectAddresses(pow, 1);
                    yield waitForBalance(pow, addressees[0].address);
                    const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                    const jobId = yield expectApplyStorageConfig(pow, cid);
                    yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                    const res = yield pow.admin.storageJobs.summary();
                    chai_1.expect(res.finalStorageJobsList).length.greaterThan(0);
                });
            });
        });
        describe("wallet", () => __awaiter(void 0, void 0, void 0, function* () {
            it("should get addresses", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    const pow = newPow();
                    const res = yield pow.admin.wallet.addresses();
                    chai_1.expect(res.addressesList).length.greaterThan(0);
                });
            });
            it("should create an address", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    const pow = newPow();
                    const res = yield pow.admin.wallet.newAddress();
                    chai_1.expect(res.address).not.empty;
                });
            });
            it("should send fil", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    this.timeout(20000);
                    const pow = newPow();
                    const res0 = yield pow.admin.wallet.newAddress();
                    const res1 = yield pow.admin.wallet.newAddress();
                    yield waitForBalance(pow, res0.address);
                    const bal = yield waitForBalance(pow, res1.address);
                    yield pow.admin.wallet.sendFil(res0.address, res1.address, BigInt(10));
                    yield waitForBalance(pow, res1.address, bal);
                });
            });
        }));
        describe("data", () => {
            it("should gc staged", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    this.timeout(180000);
                    const pow = newPow();
                    yield expectNewUser(pow);
                    const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                    const res = yield pow.admin.data.gcStaged();
                    chai_1.expect(res.unpinnedCidsList).length(1);
                    chai_1.expect(res.unpinnedCidsList[0]).equals(cid);
                });
            });
            it("should get pinned cids", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    this.timeout(30000);
                    const pow = newPow();
                    const { id } = yield expectNewUser(pow);
                    const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                    const opts = {
                        storageConfig: {
                            repairable: false,
                            hot: {
                                enabled: true,
                                allowUnfreeze: false,
                                unfreezeMaxPrice: 0,
                                ipfs: {
                                    addTimeout: 300,
                                },
                            },
                        },
                    };
                    const jobId = yield expectApplyStorageConfig(pow, cid, opts);
                    yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                    const res = yield pow.admin.data.pinnedCids();
                    chai_1.expect(res.cidsList).length(1);
                    chai_1.expect(res.cidsList[0].cid).equals(cid);
                    chai_1.expect(res.cidsList[0].usersList).length(1);
                    chai_1.expect(res.cidsList[0].usersList[0].userId).equals(id);
                });
            });
        });
        describe("storage info", () => {
            it("should get", function () {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    this.timeout(180000);
                    const pow = newPow();
                    const { id } = yield expectNewUser(pow);
                    const addressees = yield expectAddresses(pow, 1);
                    yield waitForBalance(pow, addressees[0].address);
                    const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                    const jobId = yield expectApplyStorageConfig(pow, cid);
                    yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                    const res = yield pow.admin.storageInfo.get(id, cid);
                    chai_1.expect(res === null || res === void 0 ? void 0 : res.storageInfo).not.undefined;
                    chai_1.expect((_a = res === null || res === void 0 ? void 0 : res.storageInfo) === null || _a === void 0 ? void 0 : _a.cid).equals(cid);
                });
            });
            it("should list", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    this.timeout(180000);
                    const pow = newPow();
                    const { id } = yield expectNewUser(pow);
                    const addressees = yield expectAddresses(pow, 1);
                    yield waitForBalance(pow, addressees[0].address);
                    const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                    const jobId = yield expectApplyStorageConfig(pow, cid);
                    yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                    let res = yield pow.admin.storageInfo.list();
                    chai_1.expect(res.storageInfoList).length(1);
                    res = yield pow.admin.storageInfo.list([id]);
                    chai_1.expect(res.storageInfoList).length(1);
                    res = yield pow.admin.storageInfo.list([id], [cid]);
                    chai_1.expect(res.storageInfoList).length(1);
                    res = yield pow.admin.storageInfo.list(undefined, [cid]);
                    chai_1.expect(res.storageInfoList).length(1);
                    chai_1.expect(res === null || res === void 0 ? void 0 : res.storageInfoList[0].cid).equals(cid);
                });
            });
        });
        describe("records", function () {
            it("should get updated deal records since", function () {
                return __awaiter(this, void 0, void 0, function* () {
                    this.timeout(180000);
                    const t = new Date();
                    const pow = newPow();
                    yield expectNewUser(pow);
                    const addressees = yield expectAddresses(pow, 1);
                    yield waitForBalance(pow, addressees[0].address);
                    const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                    const jobId = yield expectApplyStorageConfig(pow, cid);
                    yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                    const res = yield pow.admin.records.getUpdatedStorageDealRecordsSince(t, 10);
                    chai_1.expect(res.recordsList).length(1);
                    chai_1.expect(res.recordsList[0].rootCid).eq(cid);
                });
            });
            // TODO: Figure out how to test retrievals.
        });
        describe("indices", function () {
            return __awaiter(this, void 0, void 0, function* () {
                it("should get miners", function () {
                    return __awaiter(this, void 0, void 0, function* () {
                        const pow = newPow();
                        yield expectGetMiners(pow);
                    });
                });
                it("should get miner info", function () {
                    return __awaiter(this, void 0, void 0, function* () {
                        const pow = newPow();
                        const miners = yield expectGetMiners(pow);
                        const res = yield pow.admin.indices.getMinerInfo(miners[0].address);
                        chai_1.expect(res.minersInfoList).length(1);
                        chai_1.expect(res.minersInfoList[0].address).eq(miners[0].address);
                    });
                });
            });
        });
    });
    describe("data", () => {
        it("should get cid summary", function () {
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(180000);
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                let res = yield pow.data.cidSummary();
                chai_1.expect(res.cidSummaryList).length(1);
                res = yield pow.data.cidSummary(cid);
                chai_1.expect(res.cidSummaryList).length(1);
                chai_1.expect(res.cidSummaryList[0].cid).equals(cid);
                chai_1.expect(res.cidSummaryList[0].executingJob).equals(jobId);
            });
        });
        it("should get cid info", function () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(180000);
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                let res = yield pow.data.cidInfo(cid);
                chai_1.expect(res.cidInfo).not.undefined;
                chai_1.expect((_a = res.cidInfo) === null || _a === void 0 ? void 0 : _a.cid).equals(cid);
                chai_1.expect((_b = res.cidInfo) === null || _b === void 0 ? void 0 : _b.currentStorageInfo).undefined;
                chai_1.expect((_c = res.cidInfo) === null || _c === void 0 ? void 0 : _c.latestPushedStorageConfig).not.undefined;
                chai_1.expect((_d = res.cidInfo) === null || _d === void 0 ? void 0 : _d.queuedStorageJobsList).length.lessThan(2);
                if ((_e = res.cidInfo) === null || _e === void 0 ? void 0 : _e.executingStorageJob) {
                    chai_1.expect((_f = res.cidInfo) === null || _f === void 0 ? void 0 : _f.executingStorageJob.cid).equals(cid);
                }
                yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                res = yield pow.data.cidInfo(cid);
                chai_1.expect(res.cidInfo).not.undefined;
                chai_1.expect((_g = res.cidInfo) === null || _g === void 0 ? void 0 : _g.cid).equals(cid);
                chai_1.expect((_j = (_h = res.cidInfo) === null || _h === void 0 ? void 0 : _h.currentStorageInfo) === null || _j === void 0 ? void 0 : _j.cid).equals(cid);
                chai_1.expect((_k = res.cidInfo) === null || _k === void 0 ? void 0 : _k.latestPushedStorageConfig).not.undefined;
                chai_1.expect((_l = res.cidInfo) === null || _l === void 0 ? void 0 : _l.queuedStorageJobsList).length(0);
                chai_1.expect((_m = res.cidInfo) === null || _m === void 0 ? void 0 : _m.executingStorageJob).undefined;
            });
        });
        it("should get", function () {
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(180000);
                const pow = newPow();
                yield expectNewUser(pow);
                const addrs = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addrs[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                const bytes = yield pow.data.get(cid);
                chai_1.expect(bytes.byteLength).greaterThan(0);
            });
        });
        it("should get a folder", () => __awaiter(void 0, void 0, void 0, function* () {
            const pow = newPow();
            yield expectNewUser(pow);
            const res = yield pow.data.stageFolder("./sample-data");
            chai_1.expect(res).length.greaterThan(0);
            yield pow.data.getFolder(res, "./output", { timeout: 10000 });
        }));
        it("should replace", function () {
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(360000);
                const pow = newPow();
                yield expectNewUser(pow);
                const addrs = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addrs[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                const cid2 = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const res = yield pow.data.replaceData(cid, cid2);
                chai_1.expect(res.jobId).length.greaterThan(0);
                yield watchJobUntil(pow, res.jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
            });
        });
        it("should stage", () => __awaiter(void 0, void 0, void 0, function* () {
            const pow = newPow();
            yield expectNewUser(pow);
            yield expectStage(pow, crypto_1.default.randomBytes(1024));
        }));
        it("should stage folder", () => __awaiter(void 0, void 0, void 0, function* () {
            const pow = newPow();
            yield expectNewUser(pow);
            const res = yield pow.data.stageFolder("sample-data");
            chai_1.expect(res).not.empty;
        }));
        it("should watch logs", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                const event = yield new Promise((resolve) => {
                    pow.data.watchLogs((event) => resolve(event), cid, { includeHistory: true, jobId });
                });
                chai_1.expect(event.cid).equals(cid);
                chai_1.expect(event.jobId).equals(jobId);
            });
        });
    });
    describe("deals", () => {
        it("should get storage deal records", function () {
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(180000);
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                const pending = yield pow.deals.storageDealRecords({ includePending: true });
                const final = yield pow.deals.storageDealRecords({ includeFinal: true });
                chai_1.expect(pending.recordsList).empty;
                chai_1.expect(final.recordsList).length(1);
            });
        });
        it("should get retreival deal records", () => {
            // ToDo: Figre out how to force a retrieval to test this.
        });
    });
    describe("storage config", () => {
        it("should get default", () => __awaiter(void 0, void 0, void 0, function* () {
            const pow = newPow();
            yield expectNewUser(pow);
            yield expectDefaultStorageConfig(pow);
        }));
        it("should set default", () => __awaiter(void 0, void 0, void 0, function* () {
            const pow = newPow();
            yield expectNewUser(pow);
            const conf = yield expectDefaultStorageConfig(pow);
            yield pow.storageConfig.setDefault(conf);
        }));
        it("should apply", () => __awaiter(void 0, void 0, void 0, function* () {
            const pow = newPow();
            yield expectNewUser(pow);
            const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
            yield expectApplyStorageConfig(pow, cid);
        }));
        it("should remove", () => __awaiter(void 0, void 0, void 0, function* () {
            const pow = newPow();
            yield expectNewUser(pow);
            const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
            const conf = yield expectDefaultStorageConfig(pow);
            conf.cold = Object.assign(Object.assign({}, conf.cold), { enabled: false });
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            conf.hot = Object.assign(Object.assign({}, conf.hot), { enabled: false });
            yield expectApplyStorageConfig(pow, cid, { storageConfig: conf });
            yield pow.storageConfig.remove(cid);
        }));
    });
    describe("storage jobs", () => {
        it("should cancel", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                yield pow.storageJobs.cancel(jobId);
            });
        });
        it("should get executing", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_EXECUTING);
                let res = yield pow.storageJobs.list({ select: storage_jobs_1.ListSelect.Executing });
                chai_1.expect(res.storageJobsList).length(1);
                res = yield pow.storageJobs.list({
                    cidFilter: cid,
                    select: storage_jobs_1.ListSelect.Executing,
                });
                chai_1.expect(res.storageJobsList).length(1);
                chai_1.expect(res.storageJobsList[0].id).equals(jobId);
                chai_1.expect(res.storageJobsList[0].cid).equals(cid);
            });
        });
        it("should get queued", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                yield expectApplyStorageConfig(pow, cid);
                const res = yield pow.storageJobs.list({
                    cidFilter: cid,
                    select: storage_jobs_1.ListSelect.Queued,
                });
                chai_1.expect(res.storageJobsList).length.lessThan(2);
            });
        });
        it("should get storage config for job", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                const res = yield pow.storageJobs.storageConfig(jobId);
                chai_1.expect(res.storageConfig).not.undefined;
            });
        });
        it("should get storage job", function () {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                const res = yield pow.storageJobs.get(jobId);
                chai_1.expect((_a = res.storageJob) === null || _a === void 0 ? void 0 : _a.id).equals(jobId);
            });
        });
        it("should get summary", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                let res = yield pow.storageJobs.summary();
                chai_1.expect(res.executingStorageJobsList).length(1);
                res = yield pow.storageJobs.summary(cid);
                chai_1.expect(res.executingStorageJobsList).length(1);
                chai_1.expect(res.executingStorageJobsList[0]).equals(jobId);
            });
        });
        it("should watch", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_EXECUTING);
            });
        });
    });
    describe("storage info", () => {
        it("should get", function () {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(180000);
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                const res = yield pow.storageInfo.get(cid);
                chai_1.expect(res === null || res === void 0 ? void 0 : res.storageInfo).not.undefined;
                chai_1.expect((_a = res === null || res === void 0 ? void 0 : res.storageInfo) === null || _a === void 0 ? void 0 : _a.cid).equals(cid);
            });
        });
        it("should list", function () {
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(180000);
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
                const cid = yield expectStage(pow, crypto_1.default.randomBytes(1024));
                const jobId = yield expectApplyStorageConfig(pow, cid);
                yield watchJobUntil(pow, jobId, _1.powTypes.JobStatus.JOB_STATUS_SUCCESS);
                let res = yield pow.storageInfo.list();
                chai_1.expect(res.storageInfoList).length(1);
                res = yield pow.storageInfo.list(cid);
                chai_1.expect(res.storageInfoList).length(1);
                chai_1.expect(res === null || res === void 0 ? void 0 : res.storageInfoList[0].cid).equals(cid);
            });
        });
    });
    describe("wallet", () => {
        it("should get addresses", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                yield expectAddresses(pow, 1);
            });
        });
        it("should get balance", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                yield waitForBalance(pow, addressees[0].address);
            });
        });
        it("should create new address", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const res = yield pow.wallet.newAddress("new one");
                chai_1.expect(res.address).not.empty;
            });
        });
        it("should send fil", function () {
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(120000);
                const pow = newPow();
                yield expectNewUser(pow);
                yield pow.wallet.newAddress("new one");
                const addressees = yield expectAddresses(pow, 2);
                yield waitForBalance(pow, addressees[0].address);
                const bal = yield waitForBalance(pow, addressees[1].address);
                yield pow.wallet.sendFil(addressees[0].address, addressees[1].address, BigInt(10));
                yield waitForBalance(pow, addressees[1].address, bal);
            });
        });
        it("should sign message", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                const res = yield pow.wallet.signMessage(addressees[0].address, crypto_1.default.randomBytes(1024));
                chai_1.expect(res.signature).not.empty;
            });
        });
        it("should verify message signature", function () {
            return __awaiter(this, void 0, void 0, function* () {
                const pow = newPow();
                yield expectNewUser(pow);
                const addressees = yield expectAddresses(pow, 1);
                const message = crypto_1.default.randomBytes(1024);
                const res0 = yield pow.wallet.signMessage(addressees[0].address, message);
                const res1 = yield pow.wallet.verifyMessage(addressees[0].address, message, res0.signature);
                chai_1.expect(res1.ok).true;
            });
        });
    });
});
function newPow() {
    return _1.createPow({ host: util_1.host });
}
function expectNewUser(pow) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield pow.admin.users.create();
        chai_1.expect((_a = res.user) === null || _a === void 0 ? void 0 : _a.id).not.empty;
        chai_1.expect((_b = res.user) === null || _b === void 0 ? void 0 : _b.token).not.empty;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        pow.setToken(res.user.token);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return res.user;
    });
}
function expectDefaultStorageConfig(pow) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield pow.storageConfig.default();
        chai_1.expect(res.defaultStorageConfig).not.undefined;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return res.defaultStorageConfig;
    });
}
function expectStage(pow, data) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield pow.data.stage(data);
        chai_1.expect(res.cid).length.greaterThan(0);
        return res.cid;
    });
}
function expectApplyStorageConfig(pow, cid, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield pow.storageConfig.apply(cid, opts);
        chai_1.expect(res.jobId).length.greaterThan(0);
        return res.jobId;
    });
}
function watchJobUntil(pow, jobId, status) {
    return new Promise((resolve, reject) => {
        try {
            const cancel = pow.storageJobs.watch((job) => {
                if (job.errorCause.length > 0) {
                    reject(job.errorCause);
                }
                if (job.status === _1.powTypes.JobStatus.JOB_STATUS_CANCELED) {
                    reject("job canceled");
                }
                if (job.status === _1.powTypes.JobStatus.JOB_STATUS_FAILED) {
                    reject("job failed");
                }
                if (job.status === status) {
                    cancel();
                    resolve();
                }
            }, jobId);
        }
        catch (e) {
            reject(e);
        }
    });
}
function expectAddresses(pow, length) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield pow.wallet.addresses();
        chai_1.expect(res.addressesList).length(length);
        return res.addressesList;
    });
}
function waitForBalance(pow, address, greaterThan) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        while (true) {
            try {
                const res = yield pow.wallet.balance(address);
                const balace = BigInt(res.balance);
                if (balace > (greaterThan || BigInt(0))) {
                    resolve(balace);
                    break;
                }
            }
            catch (e) {
                reject(e);
            }
            yield new Promise((r) => setTimeout(r, 1000));
        }
    }));
}
function expectGetMiners(pow) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield pow.admin.indices.getMiners();
        chai_1.expect(res.minersList).length(1);
        return res.minersList;
    });
}
//# sourceMappingURL=integration.spec.js.map